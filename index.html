<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>決戰！五子棋</title>
<style>
#header {
text-align: center;
font-size: 32px;
color: #b22222;
margin: 20px 0;
text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
}
#rules {
max-width: 600px;
margin: 20px auto;
padding: 15px;
background: #fff;
border-radius: 8px;
box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
body {
display: flex;
flex-direction: column;
align-items: center;
font-family: "Microsoft JhengHei", Arial, sans-serif;
background: #f0f0f0;
margin: 0;
padding: 10px;
}
#board {
border-collapse: collapse;
background: #e6a23c; /* 棋盤顏色調深 */
margin: 10px auto;
box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}
td {
width: 50px;
height: 50px;
border: 1px solid #8b4513;
text-align: center;
font-size: 18px;
font-weight: bold;
color: #333;
position: relative;
cursor: pointer;
}
.black {
position: relative;
}
.black::after {
content: '';
width: 36px;
height: 36px;
border-radius: 50%;
background: #000;
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
z-index: 2;
}
.white {
position: relative;
}
.white::after {
content: '';
width: 36px;
height: 36px;
border-radius: 50%;
background: #fff;
box-shadow: 0 0 5px rgba(0,0,0,0.3);
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
z-index: 2;
}
.move-number {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
font-size: 12px;
z-index: 3;
}
.black .move-number { color: white; }
.white .move-number { color: black; }
.mark::before {
content: '';
width: 12px;
height: 12px;
border-radius: 50%;
background: #ff0000;
position: absolute;
top: 4px;
right: 4px;
z-index: 3;
box-shadow: 0 0 3px white;
border: 2px solid white;
}
.preview::after {
content: '';
width: 36px;
height: 36px;
border: 3px solid rgba(33, 150, 243, 0.8);
border-radius: 50%;
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
z-index: 1;
animation: pulse 1.5s infinite;
box-shadow: 0 0 8px rgba(33, 150, 243, 0.5);
}
@keyframes pulse {
0% {
transform: translate(-50%, -50%) scale(0.9);
opacity: 0.8;
}
50% {
transform: translate(-50%, -50%) scale(1.15);
opacity: 1;
}
100% {
transform: translate(-50%, -50%) scale(0.9);
opacity: 0.8;
}
}
#status {
font-size: 24px;
margin: 10px;
color: #333;
}
#controls {
display: flex;
gap: 15px;
margin-bottom: 15px;
flex-wrap: wrap;
justify-content: center;
}
#controls button {
padding: 12px 24px;
font-size: 18px;
cursor: pointer;
color: white;
border: none;
border-radius: 6px;
transition: opacity 0.3s;
}
#controls button.undo {
background: #ff4444;
}
#controls button.reset {
background: #2196F3;
}
#markToggle {
background: #ff0000;
}
#forbiddenToggle {
background: #3f51b5;
}
#timerToggle {
background: #4CAF50;
}
#pauseResumeTimer {
background: #FF9800;
}
/* 計時器樣式 */
#timer-container {
display: flex;
gap: 30px;
margin: 15px 0;
align-items: center;
}
.timer-box {
background: white;
border-radius: 10px;
padding: 15px 20px;
box-shadow: 0 2px 10px rgba(0,0,0,0.1);
text-align: center;
min-width: 120px;
}
.timer-label {
font-size: 16px;
font-weight: bold;
margin-bottom: 5px;
}
.timer-time {
font-size: 24px;
font-weight: bold;
font-family: 'Courier New', monospace;
}
.black-timer .timer-label { color: #000; }
.white-timer .timer-label { color: #666; }
.black-timer.active { border: 3px solid #000; }
.white-timer.active { border: 3px solid #666; }
.timer-low { color: #ff0000 !important; }
/* 炸彈樣式 */
.forbidden::before {
content: '💣';
font-size: 30px;
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
z-index: 4;
animation: bomb-pulse 1s infinite;
filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
}
@keyframes bomb-pulse {
0% {
transform: translate(-50%, -50%) scale(1);
}
50% {
transform: translate(-50%, -50%) scale(1.2);
}
100% {
transform: translate(-50%, -50%) scale(1);
}
}
/* 禁手棋子樣式 - 半透明黑棋 */
.forbidden-stone::after {
content: '';
width: 36px;
height: 36px;
border-radius: 50%;
background: rgba(0, 0, 0, 0.4); /* 半透明黑色 */
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
z-index: 2;
border: 2px solid rgba(255, 0, 0, 0.8); /* 紅色邊框 */
}
.forbidden-stone .move-number {
color: rgba(255, 255, 255, 0.8);
}
button:hover {
opacity: 0.8;
}
@media (max-width: 600px) {
td {
width: 30px;
height: 30px;
font-size: 14px;
}
.black::after, .white::after {
width: 22px;
height: 22px;
}
.preview::after {
width: 22px;
height: 22px;
border-width: 2px;
box-shadow: 0 0 5px rgba(33, 150, 243, 0.5);
}
.mark::before {
width: 8px;
height: 8px;
top: 3px;
right: 3px;
}
.move-number {
font-size: 10px;
}
#status {
font-size: 20px;
}
button {
padding: 10px 20px;
font-size: 16px;
}
.forbidden::before {
font-size: 20px;
}
.forbidden-stone::after {
width: 22px;
height: 22px;
}
#timer-container {
gap: 15px;
}
.timer-box {
padding: 10px 15px;
min-width: 100px;
}
.timer-time {
font-size: 18px;
}
}
/* 新增的連線高亮和煙火效果樣式 */
.winning-stone::after {
box-shadow: 0 0 10px 5px gold !important;
animation: pulse-win 1s infinite !important;
}
@keyframes pulse-win {
0% {
transform: translate(-50%, -50%) scale(0.9);
box-shadow: 0 0 10px 5px gold;
}
50% {
transform: translate(-50%, -50%) scale(1.1);
box-shadow: 0 0 15px 8px gold;
}
100% {
transform: translate(-50%, -50%) scale(0.9);
box-shadow: 0 0 10px 5px gold;
}
}
.firecracker-container {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 1000;
}
.firecracker-particle {
position: absolute;
width: 8px;
height: 8px;
border-radius: 50%;
animation: firecracker 1.5s ease-out forwards;
}
@keyframes firecracker {
0% {
transform: translate(0, 0) scale(0);
opacity: 1;
}
100% {
transform: translate(var(--x), var(--y)) scale(1.5);
opacity: 0;
}
}
/* 爆炸特效樣式 */
.explosion-container {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 1000;
}
.explosion-particle {
position: absolute;
width: 6px;
height: 6px;
border-radius: 50%;
animation: explosion 1s ease-out forwards;
}
@keyframes explosion {
0% {
transform: translate(0, 0) scale(1);
opacity: 1;
}
50% {
transform: translate(var(--x), var(--y)) scale(1.5);
opacity: 0.8;
}
100% {
transform: translate(var(--x), var(--y)) scale(0);
opacity: 0;
}
}
.explosion-flash {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(255, 255, 255, 0.8);
pointer-events: none;
z-index: 999;
animation: flash 0.3s ease-out;
}
@keyframes flash {
0% { opacity: 0; }
50% { opacity: 1; }
100% { opacity: 0; }
}
</style>
</head>
<body>
<h1 id="header">決戰！明智五子棋！</h1>
<div id="status">黑棋回合</div>


<!-- 計時器容器 -->
<div id="timer-container" style="display: none;">
<div class="timer-box black-timer active" id="blackTimer">
<div class="timer-label">黑棋時間</div>
<div class="timer-time" id="blackTime">5:00</div>
</div>
<div class="timer-box white-timer" id="whiteTimer">
<div class="timer-label">白棋時間</div>
<div class="timer-time" id="whiteTime">5:00</div>
</div>
</div>


<div id="controls">
<button class="undo" onclick="undoMove()">悔棋</button>
<button class="reset" onclick="resetGame()">新遊戲</button>
<button id="markToggle" onclick="toggleMarking()">開啟註記</button>
<button id="forbiddenToggle" onclick="toggleForbiddenDetection()">開啟禁手檢測</button>
<button id="timerToggle" onclick="toggleTimer()">開啟計時</button>
<button id="pauseResumeTimer" onclick="togglePauseTimer()" style="display: none;">暫停計時</button>
</div>
<table id="board"></table>
<div id="rules">
<h3>遊戲規則：</h3>
<ul>
<li>🎪 燈牌排隊連線</li>
<li>💎 贊助50 插隊&復活</li>
<li>🎤 贏主播隨機表演才藝</li>
<li>🚫禁止偷偷使用AI代下</li>
<li>⚫ 黑棋禁手：（下了就算輸，可禁可不禁）
<ul><li>禁止雙活三（同時形成兩個活三）</li>
<li>禁止雙四（同時形成兩個四）</li>
<li>禁止長連（超過五子連線）</li>
</ul>
</li>
<li>⚪ 白棋無任何限制</li>
<li>⏳合計下滿100手自動合棋</li>
<li>⏰ 每人思考時間5分鐘，每手+3秒，時間耗盡直接落敗</li>
</ul>
</div>
<script>
const BOARD_SIZE = 15;
let currentPlayer = 1;
let boardData = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
let moveHistory = [];
let stepNumber = 1;
let isMarking = false;
let isForbiddenDetectionEnabled = false;
let prePlacePosition = null;
let numberMatrix = generateSpiralMatrix(BOARD_SIZE);
let gameOver = false;


// 計時器相關變數
let isTimerEnabled = false;
let isPaused = false;
let blackTimeRemaining = 300; // 5分鐘 = 300秒
let whiteTimeRemaining = 300; // 5分鐘 = 300秒
let timerInterval = null;


// Audio context for sound generation
let audioContext;


// 初始化音頻上下文
function initAudioContext() {
if (!audioContext) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
}
}


// 生成下棋聲音
function playMoveSound() {
initAudioContext();
const oscillator = audioContext.createOscillator();
const gainNode = audioContext.createGain();
const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1,
audioContext.sampleRate);
const noiseData = noiseBuffer.getChannelData(0);
// 生成白噪音
for (let i = 0; i < noiseData.length; i++) {
noiseData[i] = (Math.random() * 2 - 1) * 0.3;
}
const noiseSource = audioContext.createBufferSource();
noiseSource.buffer = noiseBuffer;
const filter = audioContext.createBiquadFilter();
filter.type = 'highpass';
filter.frequency.value = 800;
// 設置音量包絡
gainNode.gain.setValueAtTime(0.8, audioContext.currentTime);
gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
noiseSource.connect(filter);
filter.connect(gainNode);
gainNode.connect(audioContext.destination);
noiseSource.start();
noiseSource.stop(audioContext.currentTime + 0.08);
}


// 生成勝利音效（慶祝音樂）
function playVictorySound() {
initAudioContext();
const duration = 2;
const buffer = audioContext.createBuffer(1, audioContext.sampleRate * duration, audioContext.sampleRate);
const data = buffer.getChannelData(0);


// 生成勝利旋律
for (let i = 0; i < data.length; i++) {
const time = i / audioContext.sampleRate;
// 主旋律（C大調音階上行）
const frequencies = [523.25, 587.33, 659.25, 698.46, 783.99]; // C5, D5, E5, F5, G5
const noteIndex = Math.floor(time * 5) % frequencies.length;
const freq = frequencies[noteIndex];
// 生成音符
const noteValue = Math.sin(time * freq * 2 * Math.PI) * 0.3;
// 加入和聲
const harmonyValue = Math.sin(time * freq * 1.5 * 2 * Math.PI) * 0.15;
// 包絡線
const envelope = Math.exp(-time * 0.8);
data[i] = (noteValue + harmonyValue) * envelope;
}


const source = audioContext.createBufferSource();
source.buffer = buffer;
const gainNode = audioContext.createGain();
gainNode.gain.setValueAtTime(0.6, audioContext.currentTime);
gainNode.gain.exponentialRampToValueAtTime(0.1, audioContext.currentTime + duration);
source.connect(gainNode);
gainNode.connect(audioContext.destination);
source.start();
}


// 生成地雷爆炸聲音（加強版）
function playExplosionSound() {
initAudioContext();
const duration = 1.2;
const buffer = audioContext.createBuffer(1, audioContext.sampleRate * duration, audioContext.sampleRate);
const data = buffer.getChannelData(0);


// 生成強烈的爆炸聲音
for (let i = 0; i < data.length; i++) {
const time = i / audioContext.sampleRate;
const decay = Math.exp(-time * 3);
// 低頻爆炸聲（像地雷一樣的轟隆聲）
const lowFreqNoise = (Math.random() * 2 - 1) * decay * 1.2;
// 高頻破碎聲
const highFreqNoise = (Math.random() * 2 - 1) * decay * 0.8 * Math.exp(-time * 8);
// 衝擊波效果（低頻震動）
const shockWave = Math.sin(time * 40 * (1 - time * 0.5)) * decay * 0.6;
data[i] = (lowFreqNoise + highFreqNoise + shockWave);
}


const source = audioContext.createBufferSource();
source.buffer = buffer;
const filter = audioContext.createBiquadFilter();
filter.type = 'lowpass';
filter.frequency.value = 200; // 更低頻，更有地雷爆炸的感覺
const gainNode = audioContext.createGain();
gainNode.gain.setValueAtTime(2.0, audioContext.currentTime); // 大幅增加音量
gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
source.connect(filter);
filter.connect(gainNode);
gainNode.connect(audioContext.destination);
source.start();
}


// 計時器相關函數
function toggleTimer() {
isTimerEnabled = !isTimerEnabled;
const button = document.getElementById('timerToggle');
const timerContainer = document.getElementById('timer-container');
const pauseButton = document.getElementById('pauseResumeTimer');
if (isTimerEnabled) {
button.textContent = '關閉計時';
timerContainer.style.display = 'flex';
pauseButton.style.display = 'inline-block';
startTimer();
} else {
button.textContent = '開啟計時';
timerContainer.style.display = 'none';
pauseButton.style.display = 'none';
stopTimer();
}
}


function togglePauseTimer() {
if (!isTimerEnabled) return;
isPaused = !isPaused;
const button = document.getElementById('pauseResumeTimer');
if (isPaused) {
button.textContent = '繼續計時';
stopTimer();
} else {
button.textContent = '暫停計時';
startTimer();
}
}


function startTimer() {
if (timerInterval) clearInterval(timerInterval);
timerInterval = setInterval(updateTimer, 1000);
}


function stopTimer() {
if (timerInterval) {
clearInterval(timerInterval);
timerInterval = null;
}
}


function updateTimer() {
if (gameOver || isPaused) return;


if (currentPlayer === 1) {
blackTimeRemaining--;
if (blackTimeRemaining <= 0) {
gameOver = true;
stopTimer();
alert("黑棋時間用完！白棋獲勝！");
updateStatus("白棋獲勝（黑棋超時）");
return;
}
} else {
whiteTimeRemaining--;
if (whiteTimeRemaining <= 0) {
gameOver = true;
stopTimer();
alert("白棋時間用完！黑棋獲勝！");
updateStatus("黑棋獲勝（白棋超時）");
return;
}
}
updateTimerDisplay();
}


function updateTimerDisplay() {
const blackTimeElement = document.getElementById('blackTime');
const whiteTimeElement = document.getElementById('whiteTime');
const blackTimerBox = document.getElementById('blackTimer');
const whiteTimerBox = document.getElementById('whiteTimer');


// 格式化時間顯示
blackTimeElement.textContent = formatTime(blackTimeRemaining);
whiteTimeElement.textContent = formatTime(whiteTimeRemaining);


// 更新活躍狀態
if (currentPlayer === 1) {
blackTimerBox.classList.add('active');
whiteTimerBox.classList.remove('active');
} else {
blackTimerBox.classList.remove('active');
whiteTimerBox.classList.add('active');
}


// 時間不足警告（少於30秒時顯示紅色）
if (blackTimeRemaining <= 30) {
blackTimeElement.classList.add('timer-low');
} else {
blackTimeElement.classList.remove('timer-low');
}


if (whiteTimeRemaining <= 30) {
whiteTimeElement.classList.add('timer-low');
} else {
whiteTimeElement.classList.remove('timer-low');
}
}


function formatTime(seconds) {
const minutes = Math.floor(seconds / 60);
const remainingSeconds = seconds % 60;
return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}


function addTimeBonus() {
// 每下一子增加3秒
if (currentPlayer === 1) {
blackTimeRemaining += 3;
} else {
whiteTimeRemaining += 3;
}
}


function generateSpiralMatrix(size) {
let matrix = Array(size).fill().map(() => Array(size).fill(0));
let directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
let currentDir = 0;
let row = Math.floor(size/2);
let col = Math.floor(size/2);
let steps = 1;
let num = 1;
while(num <= size*size) {
for(let i = 0; i < 2; i++) {
for(let j = 0; j < steps; j++) {
if(num > size*size) break;
matrix[row][col] = num++;
row += directions[currentDir][0];
col += directions[currentDir][1];
}
currentDir = (currentDir + 1) % 4;
}
steps++;
}
return matrix;
}


function createBoard() {
const board = document.getElementById('board');
board.innerHTML = '';
for(let i = 0; i < BOARD_SIZE; i++) {
const tr = document.createElement('tr');
for(let j = 0; j < BOARD_SIZE; j++) {
const td = document.createElement('td');
td.textContent = numberMatrix[i][j];
td.addEventListener('click', function() {
const row = i;
const col = j;
if (isMarking) {
this.classList.toggle('mark');
} else {
handleNormalClick(row, col, this);
}
});
tr.appendChild(td);
}
board.appendChild(tr);
}
}


function handleNormalClick(row, col, cell) {
if (boardData[row][col] !== 0 || gameOver) return;
if (prePlacePosition) {
if (prePlacePosition.row === row && prePlacePosition.col === col) {
// 檢查黑棋禁手
if (currentPlayer === 1 && isForbiddenDetectionEnabled && isForbiddenMove(row, col)) {
// 移除預覽
cell.classList.remove('preview');
prePlacePosition = null;
// 播放爆炸聲音
playExplosionSound();
// 顯示爆炸特效
showExplosionAnimation(cell);
// 確實落子但呈現特殊樣式
placeForbiddenStone(row, col);
// 延遲顯示提示，讓爆炸特效先播放
setTimeout(() => {
alert("黑棋下了禁手！白棋獲勝！");
gameOver = true;
updateStatus("白棋獲勝（黑棋禁手）");
stopTimer();
}, 800);
return;
}
placeStone(row, col);
cell.classList.remove('preview');
prePlacePosition = null;
} else {
document.querySelector(`#board tr:nth-child(${prePlacePosition.row+1}) td:nth-child(${prePlacePosition.col+1})`).classList.remove('preview');
cell.classList.add('preview');
prePlacePosition = {row, col};
}
} else {
cell.classList.add('preview');
prePlacePosition = {row, col};
}
}


// 顯示爆炸動畫
function showExplosionAnimation(targetCell) {
// 添加閃光效果
const flash = document.createElement('div');
flash.className = 'explosion-flash';
document.body.appendChild(flash);
// 創建爆炸容器
const container = document.createElement('div');
container.className = 'explosion-container';
document.body.appendChild(container);
// 獲取目標格子的位置
const rect = targetCell.getBoundingClientRect();
const centerX = rect.left + rect.width / 2;
const centerY = rect.top + rect.height / 2;
// 添加爆炸粒子
for (let i = 0; i < 50; i++) {
const particle = document.createElement('div');
particle.className = 'explosion-particle';
// 設置粒子起始位置
particle.style.left = `${centerX}px`;
particle.style.top = `${centerY}px`;
// 爆炸顏色（紅、橙、黃）
const colors = ['#ff0000', '#ff4500', '#ffa500', '#ffff00', '#ff6600'];
particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
// 設置隨機爆炸方向（更集中的爆炸效果）
const angle = Math.random() * Math.PI * 2;
const distance = Math.random() * 150 + 50;
const x = Math.cos(angle) * distance;
const y = Math.sin(angle) * distance;
particle.style.setProperty('--x', `${x}px`);
particle.style.setProperty('--y', `${y}px`);
container.appendChild(particle);
}
// 移除動畫元素
setTimeout(() => {
flash.remove();
container.remove();
}, 1000);
}


function placeForbiddenStone(row, col) {
// 記錄禁手棋步
moveHistory.push({
row: row,
col: col,
player: currentPlayer,
step: stepNumber,
forbidden: true
});
const cell = document.querySelector(`#board tr:nth-child(${row+1}) td:nth-child(${col+1})`);
cell.classList.add('forbidden-stone', 'forbidden');
const numberSpan = document.createElement('span');
numberSpan.className = 'move-number';
numberSpan.textContent = stepNumber;
cell.appendChild(numberSpan);
boardData[row][col] = currentPlayer;
stepNumber++;
}


function placeStone(row, col) {
if (gameOver) return;
document.querySelector(`#board tr:nth-child(${row+1}) td:nth-child(${col+1})`).classList.remove('preview', 'forbidden');
moveHistory.push({
row: row,
col: col,
player: currentPlayer,
step: stepNumber
});
const cell = document.querySelector(`#board tr:nth-child(${row+1}) td:nth-child(${col+1})`);
cell.classList.add(currentPlayer === 1 ? 'black' : 'white');
// 播放下棋聲音
playMoveSound();
const numberSpan = document.createElement('span');
numberSpan.className = 'move-number';
numberSpan.textContent = stepNumber;
cell.appendChild(numberSpan);
boardData[row][col] = currentPlayer;


// 添加時間獎勵
if (isTimerEnabled) {
addTimeBonus();
}


// 檢查是否獲勝
const winningPositions = checkWin(row, col);
if (winningPositions) {
// 高亮獲勝的棋子
highlightWinningStones(winningPositions);
// 播放勝利音效
playVictorySound();
// 顯示鞭炮動畫
showFirecrackerAnimation();
// 遊戲結束
gameOver = true;
// 停止計時器
stopTimer();
// 更新狀態
updateStatus(`${currentPlayer === 1 ? '黑棋' : '白棋'}獲勝！`);
// 顯示提示
setTimeout(() => {
alert(`${currentPlayer === 1 ? '黑棋' : '白棋'}獲勝！`);
}, 300);
return;
}
stepNumber++;
currentPlayer = currentPlayer === 1 ? 2 : 1;
updateStatus();
updateTimerDisplay();
// Update forbidden positions after a move
if (isForbiddenDetectionEnabled) {
updateForbiddenPositions();
}
}


// 檢查獲勝條件
function checkWin(row, col) {
const player = boardData[row][col];
if (player === 0) return false;
const directions = [
[0, 1], // horizontal
[1, 0], // vertical
[1, 1], // diagonal down-right
[1, -1] // diagonal down-left
];
for (const [dx, dy] of directions) {
let count = 1; // count the current stone
let winningPositions = [[row, col]]; // store positions of winning stones
// Check in positive direction
let r = row + dx;
let c = col + dy;
while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && boardData[r][c] === player) {
count++;
winningPositions.push([r, c]);
r += dx;
c += dy;
}
// Check in negative direction
r = row - dx;
c = col - dy;
while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && boardData[r][c] === player) {
count++;
winningPositions.push([r, c]);
r -= dx;
c -= dy;
}
if (count === 5) {
// 剛好5顆連線
return winningPositions;
}
}
return false;
}


// 高亮獲勝棋子
function highlightWinningStones(positions) {
for (const [row, col] of positions) {
const cell = document.querySelector(`#board tr:nth-child(${row+1}) td:nth-child(${col+1})`);
cell.classList.add('winning-stone');
}
}


// 顯示鞭炮效果
function showFirecrackerAnimation() {
// 創建鞭炮容器
const container = document.createElement('div');
container.className = 'firecracker-container';
document.body.appendChild(container);
// 添加鞭炮粒子
for (let i = 0; i < 80; i++) {
const particle = document.createElement('div');
particle.className = 'firecracker-particle';
// 隨機位置和顏色
particle.style.left = `${Math.random() * 100}%`;
particle.style.top = `${Math.random() * 100}%`;
particle.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
// 設置隨機終點位置
particle.style.setProperty('--x', `${(Math.random() * 400 - 200)}px`);
particle.style.setProperty('--y', `${(Math.random() * 400 - 200)}px`);
container.appendChild(particle);
}
// 移除動畫元素
setTimeout(() => {
container.remove();
}, 3000);
}


function undoMove() {
if (moveHistory.length === 0) return;
gameOver = false;
prePlacePosition = null;
document.querySelectorAll('#board td.preview').forEach(td => {
td.classList.remove('preview');
});
const lastMove = moveHistory.pop();
const { row, col, forbidden } = lastMove;
boardData[row][col] = 0;
currentPlayer = lastMove.player;
stepNumber = lastMove.step;
const cell = document.querySelector(`#board tr:nth-child(${row+1}) td:nth-child(${col+1})`);
cell.classList.remove('black', 'white', 'forbidden', 'winning-stone', 'forbidden-stone');
cell.querySelectorAll('.move-number').forEach(span => span.remove());
// Update forbidden positions after undoing a move
if (isForbiddenDetectionEnabled) {
updateForbiddenPositions();
}
updateStatus();
updateTimerDisplay();
// 重新開始計時器（如果啟用）
if (isTimerEnabled && !isPaused) {
startTimer();
}
}


function resetGame() {
boardData = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
moveHistory = [];
currentPlayer = 1;
stepNumber = 1;
isMarking = false;
gameOver = false;
prePlacePosition = null;
// 重置計時器
blackTimeRemaining = 300;
whiteTimeRemaining = 300;
isPaused = false;
document.getElementById('markToggle').textContent = '開啟註記';
document.getElementById('pauseResumeTimer').textContent = '暫停計時';
document.querySelectorAll('#board td').forEach(td => {
td.className = '';
td.querySelectorAll('.move-number').forEach(span => span.remove());
});
updateStatus();
updateTimerDisplay();
// Clear forbidden markers when resetting
clearForbiddenMarkers();
// Update forbidden positions if enabled
if (isForbiddenDetectionEnabled) {
updateForbiddenPositions();
}
// 重新開始計時器（如果啟用）
if (isTimerEnabled && !isPaused) {
startTimer();
}
}


function toggleMarking() {
isMarking = !isMarking;
const button = document.getElementById('markToggle');
if (isMarking) {
button.textContent = '關閉註記';
} else {
button.textContent = '開啟註記';
document.querySelectorAll('#board td.mark').forEach(td => td.classList.remove('mark'));
}
}


function toggleForbiddenDetection() {
isForbiddenDetectionEnabled = !isForbiddenDetectionEnabled;
const button = document.getElementById('forbiddenToggle');
if (isForbiddenDetectionEnabled) {
button.textContent = '關閉禁手檢測';
updateForbiddenPositions();
} else {
button.textContent = '開啟禁手檢測';
clearForbiddenMarkers();
}
}


function clearForbiddenMarkers() {
document.querySelectorAll('#board td.forbidden').forEach(td => {
if (!td.classList.contains('forbidden-stone')) {
td.classList.remove('forbidden');
}
});
}


function updateForbiddenPositions() {
if (!isForbiddenDetectionEnabled) return;
clearForbiddenMarkers();
// For each empty cell, check if it would be a forbidden move for black
for (let i = 0; i < BOARD_SIZE; i++) {
for (let j = 0; j < BOARD_SIZE; j++) {
if (boardData[i][j] === 0 && isForbiddenMove(i, j)) {
const cell = document.querySelector(`#board tr:nth-child(${i+1}) td:nth-child(${j+1})`);
cell.classList.add('forbidden');
}
}
}
}


function countPatternTypesInLine(line) {
let sleepingFours = 0;
let jumpFours = 0;
let activeThrees = 0;
let jumpThrees = 0;
// Sleeping four: XXXX_ or _XXXX
for (let i = 0; i <= line.length - 5; i++) {
const pattern = line.slice(i, i + 5);
if (pattern[0] === 1 && pattern[1] === 1 && pattern[2] === 1 && pattern[3] === 1 && pattern[4] === 0) {
sleepingFours++;
}
if (pattern[0] === 0 && pattern[1] === 1 && pattern[2] === 1 && pattern[3] === 1 && pattern[4] === 1) {
sleepingFours++;
}
}
// Jump four: XXX_X, XX_XX, X_XXX
for (let i = 0; i <= line.length - 5; i++) {
const pattern = line.slice(i, i + 5);
if (pattern[0] === 1 && pattern[1] === 1 && pattern[2] === 1 && pattern[3] === 0 && pattern[4] === 1) {
jumpFours++;
}
if (pattern[0] === 1 && pattern[1] === 1 && pattern[2] === 0 && pattern[3] === 1 && pattern[4] === 1) {
jumpFours++;
}
if (pattern[0] === 1 && pattern[1] === 0 && pattern[2] === 1 && pattern[3] === 1 && pattern[4] === 1) {
jumpFours++;
}
}
// Active three: _XXX_
for (let i = 0; i <= line.length - 5; i++) {
const pattern = line.slice(i, i + 5);
if (pattern[0] === 0 && pattern[1] === 1 && pattern[2] === 1 && pattern[3] === 1 && pattern[4] === 0) {
activeThrees++;
}
}
// Jump three: _XX_X_ or _X_XX_
for (let i = 0; i <= line.length - 6; i++) {
const pattern = line.slice(i, i + 6);
if (pattern[0] === 0 && pattern[1] === 1 && pattern[2] === 1 && pattern[3] === 0 && pattern[4] === 1 && pattern[5] === 0) {
jumpThrees++;
}
if (pattern[0] === 0 && pattern[1] === 1 && pattern[2] === 0 && pattern[3] === 1 && pattern[4] === 1 && pattern[5] === 0) {
jumpThrees++;
}
}
return { sleepingFours, jumpFours, activeThrees, jumpThrees };
}


function isFourThreeKillMove(row, col) {
// Temporarily place a black stone
boardData[row][col] = 1;
// Count fours and threes in each direction
let totalSleepingFours = 0;
let totalJumpFours = 0;
let totalActiveThrees = 0;
let totalJumpThrees = 0;
// Check all four directions
const directions = [
[0, 1], // horizontal
[1, 0], // vertical
[1, 1], // diagonal down-right
[1, -1] // diagonal down-left
];
for (const [dx, dy] of directions) {
const line = getLine(row, col, dx, dy);
const counts = countPatternTypesInLine(line);
totalSleepingFours += counts.sleepingFours;
totalJumpFours += counts.jumpFours;
totalActiveThrees += counts.activeThrees;
totalJumpThrees += counts.jumpThrees;
}
// Remove the temporary stone
boardData[row][col] = 0;
// Check for specific combinations
const hasSleepingFourWithActiveThree = totalSleepingFours >= 1 && totalActiveThrees >= 1;
const hasSleepingFourWithJumpThree = totalSleepingFours >= 1 && totalJumpThrees >= 1;
const hasJumpFourWithActiveThree = totalJumpFours >= 1 && totalActiveThrees >= 1;
const hasJumpFourWithJumpThree = totalJumpFours >= 1 && totalJumpThrees >= 1;
return hasSleepingFourWithActiveThree || hasSleepingFourWithJumpThree || hasJumpFourWithActiveThree || hasJumpFourWithJumpThree;
}


function isForbiddenMove(row, col) {
// Only valid for empty cells
if (boardData[row][col] !== 0) {
return false;
}
// Temporarily place a black stone
boardData[row][col] = 1;
// Check for long connect (6 or more in a row)
const hasLong = checkLongConnect(row, col);
// Check for double four
const hasDoubleFour = checkDoubleFour(row, col);
// Check for double three
const hasDoubleThree = checkDoubleThree(row, col);
// Check for four-three kill move
const hasFourThreeKill = isFourThreeKillMove(row, col);
// Remove the temporary stone
boardData[row][col] = 0;
// If it's a four-three kill move, it's allowed even if it's a double three
if (hasFourThreeKill) {
return hasLong || hasDoubleFour; // Only forbidden if it's a long connect or double four
} else {
return hasLong || hasDoubleFour || hasDoubleThree;
}
}


function checkLongConnect(row, col) {
const directions = [
[0, 1], // horizontal
[1, 0], // vertical
[1, 1], // diagonal down-right
[1, -1] // diagonal down-left
];
for (const [dx, dy] of directions) {
let count = 1; // Start with 1 for the current position
// Count in positive direction
let r = row + dx;
let c = col + dy;
while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && boardData[r][c] === 1) {
count++;
r += dx;
c += dy;
}
// Count in negative direction
r = row - dx;
c = col - dy;
while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && boardData[r][c] === 1) {
count++;
r -= dx;
c -= dy;
}
if (count >= 6) {
return true;
}
}
return false;
}


function checkDoubleFour(row, col) {
let fourCount = 0;
// Check all four directions
fourCount += countFourPatterns(getLine(row, col, 0, 1)); // Horizontal
fourCount += countFourPatterns(getLine(row, col, 1, 0)); // Vertical
fourCount += countFourPatterns(getLine(row, col, 1, 1)); // Diagonal down-right
fourCount += countFourPatterns(getLine(row, col, 1, -1)); // Diagonal down-left
return fourCount >= 2;
}


function checkDoubleThree(row, col) {
let threeCount = 0;
// Check all four directions
threeCount += countThreePatterns(getLine(row, col, 0, 1)); // Horizontal
threeCount += countThreePatterns(getLine(row, col, 1, 0)); // Vertical
threeCount += countThreePatterns(getLine(row, col, 1, 1)); // Diagonal down-right
threeCount += countThreePatterns(getLine(row, col, 1, -1)); // Diagonal down-left
return threeCount >= 2;
}


function getLine(row, col, dx, dy) {
const line = [];
// Add positions in negative direction
for (let i = 5; i > 0; i--) {
const r = row - i * dx;
const c = col - i * dy;
if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) {
line.push(9); // Out of bounds
} else {
line.push(boardData[r][c]);
}
}
// Add current position
line.push(1); // Our temporary black stone
// Add positions in positive direction
for (let i = 1; i <= 5; i++) {
const r = row + i * dx;
const c = col + i * dy;
if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) {
line.push(9); // Out of bounds
} else {
line.push(boardData[r][c]);
}
}
return line;
}


function countFourPatterns(line) {
let count = 0;
// For simplicity:
// 0 = empty, 1 = black, 2 = white, 9 = out of bounds
// Sleeping four: XXXX_ or _XXXX
for (let i = 0; i <= line.length - 5; i++) {
const pattern = line.slice(i, i + 5);
// Check if this is a sleeping four pattern
if (checkSleepingFour(pattern)) {
count++;
return count; // Return early as we only need to know if there's at least one
}
}
// Jump four: XXX_X, XX_XX, X_XXX
for (let i = 0; i <= line.length - 5; i++) {
const pattern = line.slice(i, i + 5);
// Check if this is a jump four pattern
if (checkJumpFour(pattern)) {
count++;
return count; // Return early as we only need to know if there's at least one
}
}
return count;
}


function checkSleepingFour(pattern) {
// XXXX_
if (pattern[0] === 1 && pattern[1] === 1 && pattern[2] === 1 && pattern[3] === 1 && pattern[4] === 0) {
return true;
}
// _XXXX
if (pattern[0] === 0 && pattern[1] === 1 && pattern[2] === 1 && pattern[3] === 1 && pattern[4] === 1) {
return true;
}
return false;
}


function checkJumpFour(pattern) {
// XXX_X
if (pattern[0] === 1 && pattern[1] === 1 && pattern[2] === 1 && pattern[3] === 0 && pattern[4] === 1) {
return true;
}
// XX_XX
if (pattern[0] === 1 && pattern[1] === 1 && pattern[2] === 0 && pattern[3] === 1 && pattern[4] === 1) {
return true;
}
// X_XXX
if (pattern[0] === 1 && pattern[1] === 0 && pattern[2] === 1 && pattern[3] === 1 && pattern[4] === 1) {
return true;
}
return false;
}


function countThreePatterns(line) {
let count = 0;
// Active three: _XXX_
for (let i = 0; i <= line.length - 5; i++) {
const pattern = line.slice(i, i + 5);
// Check if this is an active three pattern
if (checkActiveThree(pattern)) {
count++;
return count; // Return early as we only need to know if there's at least one
}
}
// Jump three: _XX_X_ or _X_XX_
for (let i = 0; i <= line.length - 6; i++) {
const pattern = line.slice(i, i + 6);
// Check if this is a jump three pattern
if (checkJumpThree(pattern)) {
count++;
return count; // Return early as we only need to know if there's at least one
}
}
return count;
}


function checkActiveThree(pattern) {
// _XXX_
return pattern[0] === 0 && pattern[1] === 1 && pattern[2] === 1 && pattern[3] === 1 && pattern[4] === 0;
}


function checkJumpThree(pattern) {
// _XX_X_
if (pattern[0] === 0 && pattern[1] === 1 && pattern[2] === 1 && pattern[3] === 0 && pattern[4] === 1 && pattern[5] === 0) {
return true;
}
// _X_XX_
if (pattern[0] === 0 && pattern[1] === 1 && pattern[2] === 0 && pattern[3] === 1 && pattern[4] === 1 && pattern[5] === 0) {
return true;
}
return false;
}


function updateStatus(customText) {
if (customText) {
document.getElementById('status').textContent = customText;
} else {
document.getElementById('status').textContent = `${currentPlayer === 1 ? '黑棋' : '白棋'}回合`;
}
}


createBoard();
</script>
</body>
</html>